A metodologia adotada para o Problema~3 concentrou-se em incorporar uma camada de blockchain ao \emph{cluster} distribu\'{\i}do do \emph{Attribute War}, garantindo escassez verific\'avel de pacotes e rastreabilidade das cartas sem comprometer o desempenho das partidas. O processo abrangeu o provisionamento conjunto do anel de servidores e do n\'o Ethereum, o ciclo do token ring para m\~aos iniciais, a integra\c{c}\~ao das APIs interservidores, o roteamento \emph{publish/subscribe} para clientes TCP e a valida\c{c}\~ao automatizada de cen\'arios de concorr\^encia e de liquida\c{c}\~ao \emph{on-chain}.

\subsection*{Provisionamento do cluster e par\^ametros operacionais}
O ciclo inicia com a orquestra\c{c}\~ao declarativa em \texttt{docker-compose.yml}: tr\^es servi\c{c}os \texttt{server-n}, um \texttt{client} e o \texttt{blockchain-node} compartilham a rede \texttt{game-net}. Vari\'aveis de ambiente de cada servidor (\texttt{LISTEN\_ADDR}, \texttt{API\_ADDR}, \texttt{ALL\_SERVERS}, \texttt{BLOCKCHAIN\_NODE\_URL}, \texttt{CONTRACT\_ADDRESS}, \texttt{ADMIN\_PRIVATE\_KEY}) definem portas, topologia do anel e credenciais de acesso ao contrato \emph{PackRegistry}, preservando reprodutibilidade do ambiente~\cite{docker-compose-ref}. No \emph{bootstrap}, \texttt{server/main.go} determina sua posi\c{c}\~ao no anel, configura o cliente Ethereum (\texttt{blockchain.NewClient}) com checagem de \emph{chainId} e carrega o \emph{State Manager}, o \emph{Broker} e o servi\c{c}o de matchmaking.

\subsection*{Ciclo do token ring, ledger e distribui\c{c}\~ao de cartas}
O estoque usado nas partidas permanece governado por um token que circula em anel, oferecendo exclus\~ao m\'utua e ordem total para retirada de cartas iniciais. O \texttt{MatchmakingService.Run()} bloqueia at\'e receber o token, processa filas locais e distribui m\~aos com \texttt{DrawCards()} para \texttt{CreateLocalMatchWithCards()} ou \texttt{CreateDistributedMatchAsHostWithCards()}. O l\'ider regenera o token a partir de \texttt{cards.json} quando o \emph{watchdog} expira, evitando esgotamento. Em paralelo, a escassez global de pacotes \'e delegada ao contrato \emph{PackRegistry}, que rejeita decr\'escimos indevidos e modela a propriedade como estado imut\'avel~\cite{wood2014, szabo1997}.

\subsection*{Matchmaking distribu\'{\i}do e API interservidores}
A coopera\c{c}\~ao entre servidores segue o estilo REST com mensagens JSON~\cite{fielding2000}. Quando apenas um jogador est\'a na fila local, o host percorre \texttt{ALL\_SERVERS} via \texttt{GET /api/find-opponent}; em caso de sucesso, envia \texttt{POST /api/request-match} com as cartas do convidado retiradas do token. Jogadas remotas usam \texttt{POST /matches/\{id\}/action}, aplicando \texttt{match.PlayCard()} em ambos os lados; o protocolo impede eco de mensagens ao distinguir anfitri\~ao e convidado. A passagem do token entre n\'os (\texttt{/api/receive-token}) garante que apenas um servidor manipule o \emph{pool} de cartas de partida por vez, enquanto o \emph{ledger} on-chain persiste ativos.

\subsection*{Canal cliente-servidor e roteamento publish-subscribe}
Clientes TCP autenticam-se, assinam os t\'opicos \texttt{player.\textless id\textgreater} no \texttt{pubsub.Broker} e recebem \texttt{MATCH\_FOUND}, \texttt{STATE} e \texttt{ROUND\_RESULT}. O padr\~ao \emph{publish/subscribe} desacopla produtores de consumidores, reduzindo bloqueios entre \emph{goroutines}~\cite{eugster2003}. A abertura de pacotes \texttt{OPEN\_PACK} aciona \texttt{blockchain.DecrementStock()}, espera o recibo (\texttt{WaitForTransactionReceipt}), gera cartas base via \texttt{PackSystem}, anexa UUIDs, registra a posse com \texttt{AssignCards()} e retorna \texttt{PACK\_OPENED} com estoque atualizado. A troca \texttt{/trade} chama \texttt{TransferCard()} e notifica remetente e destinat\'ario; a consulta \texttt{/collection} utiliza \texttt{GetUserCards()} para exibir NFTs j\'a registrados. O \texttt{PING/PONG} segue peri\'odico para medir lat\^encia fim a fim.

\subsection*{Automatiza\c{c}\~ao de testes e monitoramento}
A valida\c{c}\~ao automatizada usa \texttt{go test} em dois eixos. O \texttt{tests/packs\_test.go} modela concorr\^encia de abertura de pacotes com 20 \emph{goroutines}, aferindo atomici\-dade, aus\^encia de duplicatas e exaust\~ao do estoque, com logs de auditoria. O \texttt{tests/stress\_cluster\_test.go} compila o servidor, sobe tr\^es inst\^ancias, injeta centenas de clientes simulados e verifica a propor\c{c}\~ao entre \texttt{PACK\_OPENED} e \texttt{OUT\_OF\_STOCK}, mesmo sob falha intencional de um n\'o. Logs estruturados (\texttt{[BLOCKCHAIN]}, \texttt{[MATCHMAKING]}, \texttt{[MATCH]}) e o RTT medido por \texttt{PING/PONG} auxiliam o diagn\'ostico. A Tabela~\ref{tab:testes-metodologia-blockchain} resume os casos principais e as evid\^encias esperadas.

\begin{table}[htbp]
  \centering
  \caption{Casos de teste e evid\^encias de valida\c{c}\~ao do cluster com blockchain.}
  \label{tab:testes-metodologia-blockchain}
  \begin{tabular}{@{}p{1.2cm} p{3cm} p{4.2cm} p{4.0cm}@{}}
    \toprule
    \textbf{ID} & \textbf{Escopo} & \textbf{Procedimento} & \textbf{Evid\^encia de sucesso} \\
    \midrule
    T1 & Conex\~ao blockchain & Inicializar \texttt{docker-compose up} & Logs \texttt{[BLOCKCHAIN]} exibem \emph{chainId} e estoque inicial lido do contrato. \\
    T2 & Token ring & Receber e repassar token entre os tr\^es servidores & Mensagens \texttt{Token recebido/passo} alternam entre n\'os sem bloqueio. \\
    T3 & Partida distribu\'{\i}da & Conectar clientes em servidores distintos e acionar \texttt{FIND\_MATCH} & Sequ\^encia \texttt{find-opponent} $\rightarrow$ \texttt{request-match} $\rightarrow$ \texttt{MATCH\_FOUND} sim\'etrica; m\~aos id\^enticas em ambos os lados. \\
    T4 & Abertura de pacote \emph{on-chain} & Enviar \texttt{OPEN\_PACK} e aguardar confirma\c{c}\~ao & Decremento de estoque confirmado, UUIDs atribu\'{\i}dos e retorno \texttt{PACK\_OPENED}. \\
    T5 & Troca de cartas & Executar \texttt{/trade} entre dois jogadores & \texttt{TransferCard} aceita, recibo confirmado e mensagem de recebimento para o destinat\'ario. \\
    T6 & Toler\^ancia a falhas & Matar um servidor durante o teste de estresse & Demais n\'os continuam a responder; propor\c{c}\~ao \texttt{PACK\_OPENED}/\texttt{OUT\_OF\_STOCK} coerente com estoque global. \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection*{Fluxo consolidado}
O fluxo consolidado segue os passos:
\begin{enumerate}
  \item Inicializa\c{c}\~ao: cada servidor descobre sua posi\c{c}\~ao no anel, cria clientes Ethereum e valida acesso ao contrato.
  \item Regenera\c{c}\~ao do token: o l\'ider embaralha o \emph{pool} de cartas e injeta o token para iniciar o ciclo.
  \item Matchmaking: prefer\^encia por partidas locais; na falta de oponente, consulta remota e cria partida distribu\'{\i}da com cartas fornecidas pelo token.
  \item Liquida\c{c}\~ao de ativos: pedidos \texttt{OPEN\_PACK} e \texttt{/trade} emitem transa\c{c}\~oes, aguardam recibos e notificam clientes.
  \item Observabilidade: PING/PONG e logs estruturados exp\~oem lat\^encia, consumo de estoque e hashes de transa\c{c}\~ao.
  \item Repassa token: ap\'os processar filas e partidas, o n\'o serializa o token e envia ao pr\'oximo servidor, reiniciando o ciclo.
\end{enumerate}

Essa metodologia alinha a arquitetura distribu\'{\i}da com garantias fortes de posse e de escassez providas pelo \emph{ledger}, preservando a reprodutibilidade e a valida\c{c}\~ao automatizada requeridas para o Problema~3.
